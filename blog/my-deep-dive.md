# Flux
Differences at a glance.
* A separate store for each thing to store? In Redux there is only one of them, so that you could feasibly inject it by the React-Redux Provider component into the smart components.
* waitFor, is it really needed? But how would you handle the case that they use with the flight destination form? In flux it seems to be okay for several stores to depend on each other, and do stuff differently based on that. However, in Redux the changing of the stores data would be handled in a reducer, and they should not depend on other things other htan what they get passed and the same stores data, which means that either we have all data, or we don't.
* Flux utils have a ReducerStore "class" that has a pure reduce method, but they are not used in the examples? Neither is it used in the code for the tutorial projects. Either way, it seems that using the ReducerStore would be more similar to using Redux than just using plain JavaScript objects to store state. However, it still isn't a 1:1, because the store is still technically mutable, you can mutate it as long as you aren't using ImmutableJS or something. This is just odd.
* Container.create == connect, but it uses method on the actual component, getStores and calculateState to check if things are changed. There isn't any real explicity here...
* Container.create seems to store things in the state instead of in props, just a minor thing maybe.
* NuclearMail seems to be using Redux instead of flux. You could of course argue that redux is a derivate of flux and as such is more or less the same, but are they really?
* In NuclearMail the differences are quite clear. The store keeps everything, and combines a lot of reducers into a single one which only works on one part of the store, whilst Flux works on a lot of stores. There is probably some architechtural advantage to each of these.
* Looking at NuclearMail, when is it ever needed that two reducers depend on each other? Or is it just a flaw in how Flux is designed that makes it so that waitFor is actually needed?
* Flux prevents updating of things stored in the store by the sake of just not exporting the stores data? That seems odd... Redux solves it by not in any way allowing us to change the data without dispatching an action and returning a new state that will be used instead of the old one. In flux you just willy nilly change the data in the "Store" and hope that it works out.
* No injection of actions into the components, just plain old closures over actions imported into the file. It of couse works the same way, but it feels odd to not get them via props but instead explicityly have to define them. If you explicitly need to define them, to use TodoActions for example there is a higher coupling between the component and the actions. In Redux there is almost no coupling at all since the actualy component doesn't care where the method comes from, just that it is there.
* It just feels ugly. Redux feels like a well though out architechture, good examples, good code, it looks nice and is easy to write and reason about. Flux on the other hand does things a lot differently. Reducers aren't pure unless you use the flux utils ReducerStore, things are not kept in the same store which maybe makes it easier to separate different things into different places such as databases and what not, but makes for a lot of redudancy and other things like the waitFor method.
* There is only a "pseudo"-unidirectional flow in flux. Since you can waitFor events on stores, there is all possibility that you create infinite loops and other problems. I think the reason for the waitFor method is because you can add an eventlistener to a store, and that way create dependencies that wouldn't be possible in Redux. For example. In flux-chat they use waitFor in the MessagesStore to wait for the ThreadStore to update before they can mark threads read, and decrement the read count. However, this seems to be because they are using different stores, and registering events on them. If you instead just had a single reducer for each part of the store, and injected the different store parts into the components, everything would be handled automatically, and is incidentally how you would handle it in Redux.

Next step would be to port ContactApp to be a flux application and compare the differences.
